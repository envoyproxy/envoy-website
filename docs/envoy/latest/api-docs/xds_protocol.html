

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>xDS REST and gRPC protocol &mdash; envoy 1.17.0-dev-8774b2 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/envoy.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_tabs/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Well Known Client Features" href="../api/client_features.html" />
    <link rel="prev" title="Custom Tag" href="../api-v3/type/tracing/v3/custom_tag.proto.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/envoy-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.17.0-dev-8774b2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about_docs.html">About the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../start/start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration/configuration.html">Configuration reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operations/operations.html">Operations and administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/extending.html">Extending Envoy for custom use cases</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api/api.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api/api_supported_versions.html">Supported API versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-v2/api.html">v2 API reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-v3/api.html">v3 API reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">xDS REST and gRPC protocol</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#resource-types">Resource Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filesystem-subscriptions">Filesystem subscriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#streaming-grpc-subscriptions">Streaming gRPC subscriptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#api-flow">API flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants-of-the-xds-transport-protocol">Variants of the xDS Transport Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-xds-transport-protocol">The xDS transport Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-warming">Resource warming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregated-discovery-service">Aggregated Discovery Service</a></li>
<li class="toctree-l4"><a class="reference internal" href="#incremental-xds">Incremental xDS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rest-json-polling-subscriptions">REST-JSON polling subscriptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api/client_features.html">Well Known Client Features</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/overview.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version_history/version_history.html">Version history</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">envoy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../api/api.html">API</a> &raquo;</li>
        
      <li>xDS REST and gRPC protocol</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-docs/xds_protocol.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xds-rest-and-grpc-protocol">
<span id="xds-protocol"></span><h1>xDS REST and gRPC protocol<a class="headerlink" href="#xds-rest-and-grpc-protocol" title="Permalink to this headline">¶</a></h1>
<p>Envoy discovers its various dynamic resources via the filesystem or by
querying one or more management servers. Collectively, these discovery
services and their corresponding APIs are referred to as <em>xDS</em>.
Resources are requested via <em>subscriptions</em>, by specifying a filesystem
path to watch, initiating gRPC streams, or polling a REST-JSON URL. The
latter two methods involve sending requests with a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>
proto payload. Resources are delivered in a
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
proto payload in all methods. We discuss each type of subscription
below.</p>
<div class="section" id="resource-types">
<h2>Resource Types<a class="headerlink" href="#resource-types" title="Permalink to this headline">¶</a></h2>
<p>Every configuration resource in the xDS API has a type associated with it. Resource types follow a
<a class="reference external" href="https://github.com/envoyproxy/envoy/blob/8774b21a2897939814a6c09ab11295899df1db52/api/API_VERSIONING.md">versioning scheme</a>. Resource types are versioned independent of the
transports described below.</p>
<p>The following v2 xDS resource types are supported:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">envoy.api.v2.Listener</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/route.proto.html#envoy-api-msg-routeconfiguration"><span class="std std-ref">envoy.api.v2.RouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/scoped_route.proto.html#envoy-api-msg-scopedrouteconfiguration"><span class="std std-ref">envoy.api.v2.ScopedRouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/route/route_components.proto.html#envoy-api-msg-route-virtualhost"><span class="std std-ref">envoy.api.v2.route.VirtualHost</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">envoy.api.v2.Cluster</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/endpoint.proto.html#envoy-api-msg-clusterloadassignment"><span class="std std-ref">envoy.api.v2.ClusterLoadAssignment</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/api/v2/auth/secret.proto.html#envoy-api-msg-auth-secret"><span class="std std-ref">envoy.api.v2.Auth.Secret</span></a></p></li>
<li><p><a class="reference internal" href="../api-v2/service/discovery/v2/rtds.proto.html#envoy-api-msg-service-discovery-v2-runtime"><span class="std std-ref">envoy.service.discovery.v2.Runtime</span></a></p></li>
</ul>
<p>The following v3 xdS resource types are supported:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">envoy.config.listener.v3.Listener</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">envoy.config.route.v3.RouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/scoped_route.proto.html#envoy-v3-api-msg-config-route-v3-scopedrouteconfiguration"><span class="std std-ref">envoy.config.route.v3.ScopedRouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/route_components.proto.html#envoy-v3-api-msg-config-route-v3-virtualhost"><span class="std std-ref">envoy.config.route.v3.VirtualHost</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">envoy.config.cluster.v3.Cluster</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/endpoint/v3/endpoint.proto.html#envoy-v3-api-msg-config-endpoint-v3-clusterloadassignment"><span class="std std-ref">envoy.config.endpoint.v3.ClusterLoadAssignment</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/extensions/transport_sockets/tls/v3/secret.proto.html#envoy-v3-api-msg-extensions-transport-sockets-tls-v3-secret"><span class="std std-ref">envoy.extensions.transport_sockets.tls.v3.Secret</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/service/runtime/v3/rtds.proto.html#envoy-v3-api-msg-service-runtime-v3-runtime"><span class="std std-ref">envoy.service.runtime.v3.Runtime</span></a></p></li>
</ul>
<p>The concept of <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/proto3#any">type URLs</a>
appears below, and takes the form <cite>type.googleapis.com/&lt;resource type&gt;</cite> – e.g.,
<cite>type.googleapis.com/envoy.api.v2.Cluster</cite> for a <cite>Cluster</cite> resource. In various requests from
Envoy and responses by the management server, the resource type URL is stated.</p>
</div>
<div class="section" id="filesystem-subscriptions">
<h2>Filesystem subscriptions<a class="headerlink" href="#filesystem-subscriptions" title="Permalink to this headline">¶</a></h2>
<p>The simplest approach to delivering dynamic configuration is to place it
at a well known path specified in the <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a>.
Envoy will use <cite>inotify</cite> (<cite>kqueue</cite> on macOS) to monitor the file for
changes and parse the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> proto in the file on update.
Binary protobufs, JSON, YAML and proto text are supported formats for
the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p>
<p>There is no mechanism available for filesystem subscriptions to ACK/NACK
updates beyond stats counters and logs. The last valid configuration for
an xDS API will continue to apply if an configuration update rejection
occurs.</p>
</div>
<div class="section" id="streaming-grpc-subscriptions">
<span id="xds-protocol-streaming-grpc-subscriptions"></span><h2>Streaming gRPC subscriptions<a class="headerlink" href="#streaming-grpc-subscriptions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="api-flow">
<h3>API flow<a class="headerlink" href="#api-flow" title="Permalink to this headline">¶</a></h3>
<p>For typical HTTP routing scenarios, the core resource types for the client’s configuration are
<cite>Listener</cite>, <cite>RouteConfiguration</cite>, <cite>Cluster</cite>, and <cite>ClusterLoadAssignment</cite>. Each <cite>Listener</cite> resource
may point to a <cite>RouteConfiguration</cite> resource, which may point to one or more <cite>Cluster</cite> resources,
and each <cite>Cluster</cite> resource may point to a <cite>ClusterLoadAssignment</cite> resource.</p>
<p>Envoy fetches all <cite>Listener</cite> and <cite>Cluster</cite> resources at startup. It then fetches whatever
<cite>RouteConfiguration</cite> and <cite>ClusterLoadAssignment</cite> resources that are required by the <cite>Listener</cite> and
<cite>Cluster</cite> resources. In effect, every <cite>Listener</cite> or <cite>Cluster</cite> resource is a root to part of Envoy’s
configuration tree.</p>
<p>A non-proxy client such as gRPC might start by fetching only the specific <cite>Listener</cite> resources
that it is interested in. It then fetches the <cite>RouteConfiguration</cite> resources required by those
<cite>Listener</cite> resources, followed by whichever <cite>Cluster</cite> resources are required by those
<cite>RouteConfiguration</cite> resources, followed by the <cite>ClusterLoadAssignment</cite> resources required
by the <cite>Cluster</cite> resources. In effect, the original <cite>Listener</cite> resources are the roots to
the client’s configuration tree.</p>
</div>
<div class="section" id="variants-of-the-xds-transport-protocol">
<h3>Variants of the xDS Transport Protocol<a class="headerlink" href="#variants-of-the-xds-transport-protocol" title="Permalink to this headline">¶</a></h3>
<div class="section" id="four-variants">
<h4>Four Variants<a class="headerlink" href="#four-variants" title="Permalink to this headline">¶</a></h4>
<p>There are four variants of the xDS transport protocol used via streaming gRPC, which cover all
combinations of two dimensions.</p>
<p>The first dimension is State of the World (SotW) vs. incremental. The SotW approach was the
original mechanism used by xDS, in which the client must specify all resource names it is
interested in with each request (except when making a wildcard request in LDS/CDS), and the server
must return all resources the client has subscribed to in each request (in LDS/CDS). This means
that if the client is already subscribing to 99 resources and wants to add an additional one, it
must send a request with all 100 resource names, rather than just the one new one. And the server
must then respond by sending all 100 resources, even if the 99 that were already subscribed to have
not changed (in LDS/CDS). This mechanism can be a scalability limitation, which is why the
incremental protocol variant was introduced. The incremental approach allows both the client and
server to indicate only deltas relative to their previous state – i.e., the client can say that
it wants to add or remove its subscription to a particular resource name without resending those
that have not changed, and the server can send updates only for those resources that have changed.
The incremental protocol also provides a mechanism for lazy loading of resources. For details on
the incremental protocol, see <a class="reference internal" href="#xds-protocol-delta"><span class="std std-ref">Incremental xDS</span></a> below.</p>
<p>The second dimension is using a separate gRPC stream for each resource type vs. aggregating all
resource types onto a single gRPC stream. The former approach was the original mechanism used by
xDS, and it offers an eventual consistency model. The latter approach was added for environments
in which explicit control of sequencing is required. For details, see <a class="reference internal" href="#xds-protocol-eventual-consistency-considerations"><span class="std std-ref">Eventual consistency
considerations</span></a> below.</p>
<p>So, the four variants of the xDS transport protocol are:</p>
<ol class="arabic simple">
<li><p>State of the World (Basic xDS): SotW, separate gRPC stream for each resource type</p></li>
<li><p>Incremental xDS: incremental, separate gRPC stream for each resource type</p></li>
<li><p>Aggregated Discovery Service (ADS): SotW, aggregate stream for all resource types</p></li>
<li><p>Incremental ADS: incremental, aggregate stream for all resource types</p></li>
</ol>
</div>
<div class="section" id="rpc-services-and-methods-for-each-variant">
<h4>RPC Services and Methods for Each Variant<a class="headerlink" href="#rpc-services-and-methods-for-each-variant" title="Permalink to this headline">¶</a></h4>
<p>For the non-aggregated protocol variants, there is a separate RPC service for each resource type.
Each of these RPC services can provide a method for each of the SotW and Incremental protocol
variants. Here are the RPC services and methods for each resource type:</p>
<ul class="simple">
<li><p>Listener: Listener Discovery Service (LDS)
-  SotW: ListenerDiscoveryService.StreamListeners
-  Incremental: ListenerDiscoveryService.DeltaListeners</p></li>
<li><p>RouteConfiguration: Route Discovery Service (RDS)
-  SotW: RouteDiscoveryService.StreamRoutes
-  Incremental: RouteDiscoveryService.DeltaRoutes</p></li>
<li><p>ScopedRouteConfiguration: Scoped Route Discovery Service (SRDS)
-  SotW: ScopedRouteDiscoveryService.StreamScopedRoutes
-  Incremental: ScopedRouteDiscoveryService.DeltaScopedRoutes</p></li>
<li><p>VirtualHost: Virtual Host Discovery Service (VHDS)
-  SotW: N/A
-  Incremental: VirtualHostDiscoveryService.DeltaVirtualHosts</p></li>
<li><p>Cluster: Cluster Discovery Service (CDS)
-  SotW: ClusterDiscoveryService.StreamClusters
-  Incremental: ClusterDiscoveryService.DeltaClusters</p></li>
<li><p>ClusterLoadAssignment: Endpoint Discovery Service (EDS)
-  SotW: EndpointDiscoveryService.StreamEndpoints
-  Incremental: EndpointDiscoveryService.DeltaEndpoints</p></li>
<li><p>Secret: Secret Discovery Service (SDS)
-  SotW: SecretDiscoveryService.StreamSecrets
-  Incremental: SecretDiscoveryService.DeltaSecrets</p></li>
<li><p>Runtime: Runtime Discovery Service (RTDS)
-  SotW: RuntimeDiscoveryService.StreamRuntime
-  Incremental: RuntimeDiscoveryService.DeltaRuntime</p></li>
</ul>
<p>In the aggregated protocol variants, all resource types are multiplexed on a single gRPC stream,
where each resource type is treated as a separate logical stream within the aggregated stream.
In effect, it simply combines all of the above separate APIs into a single stream by treating
requests and responses for each resource type as a separate sub-stream on the single aggregated
stream. The RPC service and methods for the aggregated protocol variants are:</p>
<ul class="simple">
<li><p>SotW: AggregatedDiscoveryService.StreamAggregatedResources</p></li>
<li><p>Incremental: AggregatedDiscoveryService.DeltaAggregatedResources</p></li>
</ul>
<p>For all of the SotW methods, the request type is <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and the response type is <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p>
<p>For all of the incremental methods, the request type is <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> and the response type is <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>.</p>
</div>
<div class="section" id="configuring-which-variant-to-use">
<h4>Configuring Which Variant to Use<a class="headerlink" href="#configuring-which-variant-to-use" title="Permalink to this headline">¶</a></h4>
<p>In the xDS API, the <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> message indicates how to
obtain resources of a particular type. If the <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a>
contains a gRPC <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-apiconfigsource"><span class="std std-ref">ApiConfigSource</span></a>, it points to an
upstream cluster for the management server; this will initiate an independent bidirectional gRPC
stream for each xDS resource type, potentially to distinct management servers. If the
<a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> contains a <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a>, it tells the client to use <a class="reference internal" href="#xds-protocol-ads"><span class="std std-ref">ADS</span></a>.</p>
<p>Currently, the client is expected to be given some local configuration that tells it how to obtain
the <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resources.
<a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> resources may include a
<a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> that indicates how the
<a class="reference internal" href="../api-v2/api/v2/route.proto.html#envoy-api-msg-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> resources are obtained, and
<a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resources may include a
<a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> that indicates how the
<a class="reference internal" href="../api-v2/api/v2/endpoint.proto.html#envoy-api-msg-clusterloadassignment"><span class="std std-ref">ClusterLoadAssignment</span></a> resources are obtained.</p>
<div class="section" id="client-configuration">
<h5>Client Configuration<a class="headerlink" href="#client-configuration" title="Permalink to this headline">¶</a></h5>
<p>In Envoy, the bootstrap file contains two <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a>
messages, one indicating how <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> resources are obtained and
another indicating how <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resources are obtained. It also
contains a separate <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-apiconfigsource"><span class="std std-ref">ApiConfigSource</span></a> message indicating
how to contact the ADS server, which will be used whenever a <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> message (either in the bootstrap file or in a <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> or <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resource obtained from a
management server) contains an <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a> message.</p>
<p>In a gRPC client that uses xDS, only ADS is supported, and the bootstrap file contains the name of
the ADS server, which will be used for all resources. The <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> messages in the <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and
<a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resources must contain <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a> messages.</p>
</div>
</div>
</div>
<div class="section" id="the-xds-transport-protocol">
<h3>The xDS transport Protocol<a class="headerlink" href="#the-xds-transport-protocol" title="Permalink to this headline">¶</a></h3>
<div class="section" id="transport-api-version">
<h4>Transport API version<a class="headerlink" href="#transport-api-version" title="Permalink to this headline">¶</a></h4>
<p>In addition the resource type version described above, the xDS wire protocol has a
transport version associated with it. This provides type versioning for messages such as
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. It is also encoded in the gRPC method name, so a server
can determine which version a client is speaking based on which method it calls.</p>
</div>
<div class="section" id="basic-protocol-overview">
<h4>Basic Protocol Overview<a class="headerlink" href="#basic-protocol-overview" title="Permalink to this headline">¶</a></h4>
<p>Each xDS stream begins with a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> from the
client, which specifies the list of resources to subscribe to, the type URL corresponding to the
subscribed resources, the node identifier, and an optional resource type instance version
indicating the most recent version of the resource type that the client has already seen (see
<a class="reference internal" href="#xds-ack-nack"><span class="std std-ref">ACK/NACK and resource type instance version</span></a> for details).</p>
<p>The server will then send a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> containing
any resources that the client has subscribed to that have changed since the last resource type
instance version that the client indicated it has seen. The server may send additional responses
at any time when the subscribed resources change.</p>
<p>Whenever the client receives a new response, it will send another request indicating whether or
not the resources in the response were valid (see
<a class="reference internal" href="#xds-ack-nack"><span class="std std-ref">ACK/NACK and resource type instance version</span></a> for details).</p>
<p>Only the first request on a stream is guaranteed to carry the node identifier.
The subsequent discovery requests on the same stream may carry an empty node
identifier. This holds true regardless of the acceptance of the discovery
responses on the same stream. The node identifier should always be identical if
present more than once on the stream. It is sufficient to only check the first
message for the node identifier as a result.</p>
</div>
<div class="section" id="ack-nack-and-resource-type-instance-version">
<span id="xds-ack-nack"></span><h4>ACK/NACK and resource type instance version<a class="headerlink" href="#ack-nack-and-resource-type-instance-version" title="Permalink to this headline">¶</a></h4>
<p>Every xDS resource type has a version string that indicates the version for that resource type.
Whenever one resource of that type changes, the version is changed.</p>
<p>In a responses sent by the xDS server, the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a> field indicates the current
version for that resource type. The client then sends another request to the server with the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> field indicating the most
recent valid version seen by the client. This provides a way for the server to determine when
it sends a version that the client considers invalid.</p>
<p>(In the <a class="reference internal" href="#xds-protocol-delta"><span class="std std-ref">incremental protocol variants</span></a>, the resource type instance
version is sent by the server in the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryresponse-system-version-info"><span class="std std-ref">system_version_info</span></a> field.
However, this information is not actually used by the client to communicate which resources are
valid, because the incremental API variants have a separate mechanism for that.)</p>
<p>The resource type instance version is separate for each resource type. When using the aggregated
protocol variants, each resource type has its own version even though all resource types are being
sent on the same stream.</p>
<p>The resource type is also separate for each xDS server (where an xDS server is identified by a
unique <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a>). When obtaining resources of a
given type from multiple xDS servers, each xDS server will have a different notion of version.</p>
<p>Note that the version for a resource type is not a property of an individual xDS stream but rather
a property of the resources themselves. If the stream becomes broken and the client creates a new
stream, the client’s initial request on the new stream should indicate the most recent version
seen by the client on the previous stream. Servers may decide to optimize by not resending
resources that the client had already seen on the previous stream, but only if they know that the
client is not subscribing to a new resource that it was not previously subscribed to. For example,
it is generally safe for servers to do this optimization for wildcard LDS and CDS requests, and it
is safe to do in environments where the clients will always subscribe to exactly the same set of
resources.</p>
<p>An example EDS request might be:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version_info</span><span class="p">:</span>
<span class="nt">node</span><span class="p">:</span> <span class="p p-Indicator">{</span><span class="nt"> id</span><span class="p">:</span> <span class="nv">envoy</span> <span class="p p-Indicator">}</span>
<span class="nt">resource_names</span><span class="p">:</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">foo</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">bar</span>
<span class="nt">type_url</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">type.googleapis.com/envoy.api.v2.ClusterLoadAssignment</span>
<span class="nt">response_nonce</span><span class="p">:</span>
</pre></div>
</div>
<p>The management server may reply either immediately or when the requested
resources are available with a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>, e.g.:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version_info</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">X</span>
<span class="nt">resources</span><span class="p">:</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">foo ClusterLoadAssignment proto encoding</span>
<span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">bar ClusterLoadAssignment proto encoding</span>
<span class="nt">type_url</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">type.googleapis.com/envoy.api.v2.ClusterLoadAssignment</span>
<span class="nt">nonce</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">A</span>
</pre></div>
</div>
<p>After processing the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>, Envoy will send a new
request on the stream, specifying the last version successfully applied
and the nonce provided by the management server. The version provides Envoy and the
management server a shared notion of the currently applied configuration,
as well as a mechanism to ACK/NACK configuration updates.</p>
</div>
<div class="section" id="ack">
<h4>ACK<a class="headerlink" href="#ack" title="Permalink to this headline">¶</a></h4>
<p>If the update was successfully applied, the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> will be <strong>X</strong>, as indicated
in the sequence diagram:</p>
<div class="figure align-default">
<img alt="Version update after ACK" src="../_images/simple-ack.svg" /></div>
</div>
<div class="section" id="nack">
<h4>NACK<a class="headerlink" href="#nack" title="Permalink to this headline">¶</a></h4>
<p>If Envoy had instead rejected configuration
update <strong>X</strong>, it would reply with <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a>
populated and its previous version, which in this case was the empty
initial version. The <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a> has
more details around the exact error message populated in the message field:</p>
<div class="figure align-default">
<img alt="No version update after NACK" src="../_images/simple-nack.svg" /></div>
<p>In the sequence diagrams, the following format is used to abbreviate messages:</p>
<ul class="simple">
<li><p><em>DiscoveryRequest</em>: (V=version_info,R=resource_names,N=response_nonce,T=type_url)</p></li>
<li><p><em>DiscoveryResponse</em>: (V=version_info,R=resources,N=nonce,T=type_url)</p></li>
</ul>
<p>After a NACK, an API update may succeed at a new version <strong>Y</strong>:</p>
<div class="figure align-default">
<img alt="ACK after NACK" src="../_images/later-ack.svg" /></div>
</div>
<div class="section" id="ack-and-nack-semantics-summary">
<h4>ACK and NACK semantics summary<a class="headerlink" href="#ack-and-nack-semantics-summary" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>The xDS client should ACK or NACK every <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
received from the management server.</p></li>
<li><p>Like all other requests, the nonce from the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
is sent as <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a>.
As described in <a class="reference internal" href="#xds-protocol-resource-update"><span class="std std-ref">resource update</span></a> the nonce is
used in certain race conditions to disambiguate between ACK and NACK.</p></li>
<li><p>ACK signifies successful configuration update and contains the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a> from the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p></li>
<li><p>NACK signifies unsuccessful configuration update and contains the previous (existing)
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a>.</p></li>
<li><p>Only the NACK should populate the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a>.</p></li>
</ul>
</div>
<div class="section" id="when-to-send-an-update">
<span id="xds-protocol-resource-update"></span><h4>When to send an update<a class="headerlink" href="#when-to-send-an-update" title="Permalink to this headline">¶</a></h4>
<p>The management server should only send updates to the Envoy client when
the resources in the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> have changed. Envoy replies
to any <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> with a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> containing the
ACK/NACK immediately after it has been either accepted or rejected. If
the management server provides the same set of resources rather than
waiting for a change to occur, it will cause needless work on both the client and the management
server, which could have a severe performance impact.</p>
<p>Within a stream, new <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> supersede any prior
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> having the same resource type. This means that
the management server only needs to respond to the latest
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> on each stream for any given resource type.</p>
</div>
<div class="section" id="how-the-client-specifies-what-resources-to-return">
<span id="xds-protocol-resource-hints"></span><h4>How the client specifies what resources to return<a class="headerlink" href="#how-the-client-specifies-what-resources-to-return" title="Permalink to this headline">¶</a></h4>
<p>xDS requests allow the client to specify a set of resource names as a hint to the server about
which resources the client is interested in. In the SotW protocol variants, this is done via the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> specified in the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>; in the incremental protocol variants,
this is done via the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> and
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> fields in the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>.</p>
<p>Normally (see below for exceptions), requests must specify the set of resource names that the
client is interested in. The management server must supply the requested resources if they exist.
The client will silently ignore any supplied resources that were not explicitly requested. When
the client sends a new request that changes the set of resources being requested, the server must
resend any newly requested resources, even if it previously sent those resources without having
been asked for them and the resources have not changed since that time. If the list of resource
names becomes empty, that means that the client is no longer interested in any resources of the
specified type.</p>
<p>For <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resource
types, there is also a “wildcard” mode, which is triggered when the initial request on the stream
for that resource type contains no resource names. In this case, the server should use
site-specific business logic to determine the full set of resources that the client is interested
in, typically based on the client’s <a class="reference internal" href="../api-v2/api/v2/core/base.proto.html#envoy-api-msg-core-node"><span class="std std-ref">node</span></a> identification. Note
that once a stream has entered wildcard mode for a given resource type, there is no way to change
the stream out of wildcard mode; resource names specified in any subsequent request on the stream
will be ignored.</p>
<div class="section" id="client-behavior">
<h5>Client Behavior<a class="headerlink" href="#client-behavior" title="Permalink to this headline">¶</a></h5>
<p>Envoy will always use wildcard mode for <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and
<a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resources. However, other xDS clients (such as gRPC clients
that use xDS) may specify explicit resource names for these resource types, for example if they
only have a singleton listener and already know its name from some out-of-band configuration.</p>
</div>
</div>
<div class="section" id="grouping-resources-into-responses">
<h4>Grouping Resources into Responses<a class="headerlink" href="#grouping-resources-into-responses" title="Permalink to this headline">¶</a></h4>
<p>In the incremental protocol variants, the server sends each resource in its own response. This
means that if the server has previously sent 100 resources and only one of them has changed, it
may send a response containing only the changed resource; it does not need to resend the 99
resources that have not changed, and the client must not delete the unchanged resources.</p>
<p>In the SotW protocol variants, all resource types except for <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> are grouped into responses
in the same way as in the incremental protocol variants. However,
<a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resource types
are handled differently: the server must include the complete state of the world, meaning that all
resources of the relevant type that are needed by the client must be included, even if they did
not change since the last response. This means that if the server has previously sent 100
resources and only one of them has changed, it must resend all 100 of them, even the 99 that were
not modified.</p>
<p>Note that all of the protocol variants operate on units of whole named resources. There is
no mechanism for providing incremental updates of repeated fields within a named resource.
Most notably, there is currently no mechanism for incrementally updating individual
endpoints within an EDS response.</p>
</div>
<div class="section" id="duplicate-resource-names">
<h4>Duplicate Resource Names<a class="headerlink" href="#duplicate-resource-names" title="Permalink to this headline">¶</a></h4>
<p>It is an error for a server to send a single response that contains the same resource name
twice. Clients should NACK responses that contain multiple instances of the same resource name.</p>
</div>
<div class="section" id="deleting-resources">
<h4>Deleting Resources<a class="headerlink" href="#deleting-resources" title="Permalink to this headline">¶</a></h4>
<p>In the incremental proocol variants, the server signals the client that a resource should be
deleted via the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryresponse-removed-resources"><span class="std std-ref">removed_resources</span></a>
field of the response. This tells the client to remove the resource from its local cache.</p>
<p>In the SotW protocol variants, the criteria for deleting resources is more complex. For
<a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resource types,
if a previously seen resource is not present in a new response, that indicates that the resource
has been removed, and the client must delete it; a response containing no resources means to delete
all resources of that type. However, for other resource types, the API provides no mechanism for
the server to tell the client that resources have been deleted; instead, deletions are indicated
implicitly by parent resources being changed to no longer refer to a child resource. For example,
when the client receives an LDS update removing a <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a>
that was previously pointing to <a class="reference internal" href="../api-v2/api/v2/route.proto.html#envoy-api-msg-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> A,
if no other <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> is pointing to <a class="reference internal" href="../api-v2/api/v2/route.proto.html#envoy-api-msg-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> A, then the client may delete A. For those resource types,
an empty <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> is effectively a no-op
from the client’s perspective.</p>
</div>
<div class="section" id="knowing-when-a-requested-resource-does-not-exist">
<h4>Knowing When a Requested Resource Does Not Exist<a class="headerlink" href="#knowing-when-a-requested-resource-does-not-exist" title="Permalink to this headline">¶</a></h4>
<p>The SotW protocol variants do not provide any explicit mechanism to determine when a requested
resource does not exist.</p>
<p>Responses for <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a>
resource types must include all resources requested by the client. However, it may not be possible
for the client to know that a resource does not exist based solely on its absence in a response,
because the delivery of the updates is eventually consistent: if the client initially sends a
request for resource A, then sends a request for resources A and B, and then sees a response
containing only resource A, the client cannot conclude that resource B does not exist, because
the response may have been sent on the basis of the first request, before the server saw the
second request.</p>
<p>For other resource types, because each resource can be sent in its own response, there is no way
to know from the next response whether the newly requested resource exists, because the next
response could be an unrelated update for another resource that had already been subscribed to
previously.</p>
<p>As a result, clients are expected to use a timeout (recommended duration is 15 seconds) after
sending a request for a new resource, after which they will consider the requested resource to
not exist if they have not received the resource. In Envoy, this is done for
<a class="reference internal" href="../api-v2/api/v2/route.proto.html#envoy-api-msg-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> and <a class="reference internal" href="../api-v2/api/v2/endpoint.proto.html#envoy-api-msg-clusterloadassignment"><span class="std std-ref">ClusterLoadAssignment</span></a> resources during <a class="reference internal" href="#xds-protocol-resource-warming"><span class="std std-ref">resource warming</span></a>.</p>
<p>Note that this timeout is not strictly necessary when using wildcard mode for <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a> resource types, because
in that case every response will contain all existing resources that are relevant to the
client, so the client can know that a resource does not exist by its absence in the next
response it sees. However, using a timeout is still recommended in this case, since it protects
against the case where the management server fails to send a response in a timely manner.</p>
<p>Note that even if a requested resource does not exist at the moment when the client requests it,
that resource could be created at any time. Management servers must remember the set of resources
being requested by the client, and if one of those resources springs into existence later, the
server must send an update to the client informing it of the new resource. Clients that initially
see a resource that does not exist must be prepared for the resource to be created at any time.</p>
</div>
<div class="section" id="unsubscribing-from-resources">
<h4>Unsubscribing From Resources<a class="headerlink" href="#unsubscribing-from-resources" title="Permalink to this headline">¶</a></h4>
<p>In the incremental protocol variants, resources can be unsubscribed to via the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field.</p>
<p>In the SotW protocol variants, each request must contain the full list of resource names being
subscribed to in the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> field,
so unsubscribing to a set of resources is done by sending a new request containing all resource
names that are still being subscribed to but not containing the resource names being unsubscribed
to. For example, if the client had previously been subscribed to resources A and B but wishes to
unsubscribe from B, it must send a new request containing only resource A.</p>
<p>Note that for <a class="reference internal" href="../api-v2/api/v2/listener.proto.html#envoy-api-msg-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v2/api/v2/cluster.proto.html#envoy-api-msg-cluster"><span class="std std-ref">Cluster</span></a>
resource types where the stream is in “wildcard” mode (see <a class="reference internal" href="#xds-protocol-resource-hints"><span class="std std-ref">How the client specifies what
resources to return</span></a> for details), the set of resources being
subscribed to is determined by the server instead of the client, so there is no mechanism
for the client to unsubscribe from resources.</p>
</div>
<div class="section" id="requesting-multiple-resources-on-a-single-stream">
<h4>Requesting Multiple Resources on a Single Stream<a class="headerlink" href="#requesting-multiple-resources-on-a-single-stream" title="Permalink to this headline">¶</a></h4>
<p>For EDS/RDS, Envoy may either generate a distinct stream for each
resource of a given type (e.g. if each <a class="reference internal" href="../api-v2/api/v2/core/config_source.proto.html#envoy-api-msg-core-configsource"><span class="std std-ref">ConfigSource</span></a> has its own
distinct upstream cluster for a management server), or may combine
together multiple resource requests for a given resource type when they
are destined for the same management server. While this is left to
implementation specifics, management servers should be capable of
handling one or more <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> for a given resource type in
each request. Both sequence diagrams below are valid for fetching two
EDS resources <cite>{foo, bar}</cite>:</p>
<p><img alt="Multiple EDS requests on the same stream" src="../_images/eds-same-stream.svg" /> <img alt="Multiple EDS requests on distinct streams" src="../_images/eds-distinct-stream.svg" /></p>
</div>
<div class="section" id="resource-updates">
<h4>Resource updates<a class="headerlink" href="#resource-updates" title="Permalink to this headline">¶</a></h4>
<p>As discussed above, Envoy may update the list of <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> it
presents to the management server in each <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> that
ACK/NACKs a specific <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. In addition, Envoy may later
issue additional <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> at a given <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> to
update the management server with new resource hints. For example, if
Envoy is at EDS version <strong>X</strong> and knows only about cluster <code class="docutils literal notranslate"><span class="pre">foo</span></code>, but
then receives a CDS update and learns about <code class="docutils literal notranslate"><span class="pre">bar</span></code> in addition, it may
issue an additional <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> for <strong>X</strong> with <cite>{foo,bar}</cite> as
<cite>resource_names</cite>.</p>
<div class="figure align-default">
<img alt="CDS response leads to EDS resource hint update" src="../_images/cds-eds-resources.svg" /></div>
<p>There is a race condition that may arise here; if after a resource hint
update is issued by Envoy at <strong>X</strong>, but before the management server
processes the update it replies with a new version <strong>Y</strong>, the resource
hint update may be interpreted as a rejection of <strong>Y</strong> by presenting an
<strong>X</strong> <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a>. To avoid this, the management server provides a
<code class="docutils literal notranslate"><span class="pre">nonce</span></code> that Envoy uses to indicate the specific <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
each <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> corresponds to:</p>
<div class="figure align-default">
<img alt="EDS update race motivates nonces" src="../_images/update-race.svg" /></div>
<p>The management server should not send a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> for any
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> that has a stale nonce. A nonce becomes stale
following a newer nonce being presented to Envoy in a
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. A management server does not need to send an
update until it determines a new version is available. Earlier requests
at a version then also become stale. It may process multiple
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> at a version until a new version is ready.</p>
<div class="figure align-default">
<img alt="Requests become stale" src="../_images/stale-requests.svg" /></div>
<p>An implication of the above resource update sequencing is that Envoy
does not expect a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> for every <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a>
it issues.</p>
</div>
</div>
<div class="section" id="resource-warming">
<span id="xds-protocol-resource-warming"></span><h3>Resource warming<a class="headerlink" href="#resource-warming" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../intro/arch_overview/upstream/cluster_manager.html#arch-overview-cluster-warming"><span class="std std-ref">Clusters</span></a> and
<a class="reference internal" href="../configuration/listeners/lds.html#config-listeners-lds"><span class="std std-ref">Listeners</span></a>
go through warming before they can serve requests. This process
happens both during <a class="reference internal" href="../intro/arch_overview/operations/init.html#arch-overview-initialization"><span class="std std-ref">Envoy initialization</span></a>
and when the <cite>Cluster</cite> or <cite>Listener</cite> is updated. Warming of
<cite>Cluster</cite> is completed only when a <cite>ClusterLoadAssignment</cite> response
is supplied by management server. Similarly, warming of <cite>Listener</cite> is
completed only when a <cite>RouteConfiguration</cite> is supplied by management
server if the listener refers to an RDS configuration. Management server
is expected to provide the EDS/RDS updates during warming. If management
server does not provide EDS/RDS responses, Envoy will not initialize
itself during the initialization phase and the updates sent via CDS/LDS
will not take effect until EDS/RDS responses are supplied.</p>
<div class="section" id="eventual-consistency-considerations">
<span id="xds-protocol-eventual-consistency-considerations"></span><h4>Eventual consistency considerations<a class="headerlink" href="#eventual-consistency-considerations" title="Permalink to this headline">¶</a></h4>
<p>Since Envoy’s xDS APIs are eventually consistent, traffic may drop
briefly during updates. For example, if only cluster <strong>X</strong> is known via
CDS/EDS, a <cite>RouteConfiguration</cite> references cluster <strong>X</strong> and is then
adjusted to cluster <strong>Y</strong> just before the CDS/EDS update providing
<strong>Y</strong>, traffic will be blackholed until <strong>Y</strong> is known about by the
Envoy instance.</p>
<p>For some applications, a temporary drop of traffic is acceptable,
retries at the client or by other Envoy sidecars will hide this drop.
For other scenarios where drop can’t be tolerated, traffic drop could
have been avoided by providing a CDS/EDS update with both <strong>X</strong> and
<strong>Y</strong>, then the RDS update repointing from <strong>X</strong> to <strong>Y</strong> and then a
CDS/EDS update dropping <strong>X</strong>.</p>
<p>In general, to avoid traffic drop, sequencing of updates should follow a
make before break model, wherein:</p>
<ul class="simple">
<li><p>CDS updates (if any) must always be pushed first.</p></li>
<li><p>EDS updates (if any) must arrive after CDS updates for the respective clusters.</p></li>
<li><p>LDS updates must arrive after corresponding CDS/EDS updates.</p></li>
<li><p>RDS updates related to the newly added listeners must arrive after CDS/EDS/LDS updates.</p></li>
<li><p>VHDS updates (if any) related to the newly added RouteConfigurations must arrive after RDS updates.</p></li>
<li><p>Stale CDS clusters and related EDS endpoints (ones no longer being referenced) can then be removed.</p></li>
</ul>
<p>xDS updates can be pushed independently if no new
clusters/routes/listeners are added or if it’s acceptable to temporarily
drop traffic during updates. Note that in case of LDS updates, the
listeners will be warmed before they receive traffic, i.e. the dependent
routes are fetched through RDS if configured. Clusters are warmed when
adding/removing/updating clusters. On the other hand, routes are not
warmed, i.e., the management plane must ensure that clusters referenced
by a route are in place, before pushing the updates for a route.</p>
</div>
</div>
<div class="section" id="aggregated-discovery-service">
<span id="xds-protocol-ads"></span><h3>Aggregated Discovery Service<a class="headerlink" href="#aggregated-discovery-service" title="Permalink to this headline">¶</a></h3>
<p>It’s challenging to provide the above guarantees on sequencing to avoid
traffic drop when management servers are distributed. ADS allow a single
management server, via a single gRPC stream, to deliver all API updates.
This provides the ability to carefully sequence updates to avoid traffic
drop. With ADS, a single stream is used with multiple independent
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>/<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> sequences multiplexed via the
type URL. For any given type URL, the above sequencing of
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> messages applies. An
example update sequence might look like:</p>
<div class="figure align-default">
<img alt="EDS/CDS multiplexed on an ADS stream" src="../_images/ads.svg" /></div>
<p>A single ADS stream is available per Envoy instance.</p>
<p>An example minimal <code class="docutils literal notranslate"><span class="pre">bootstrap.yaml</span></code> fragment for ADS configuration is:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">node</span><span class="p">:</span>
  <span class="nt">id</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;node identifier&gt;</span>
<span class="nt">dynamic_resources</span><span class="p">:</span>
  <span class="nt">cds_config</span><span class="p">:</span> <span class="p p-Indicator">{</span><span class="nt">ads</span><span class="p">:</span> <span class="p p-Indicator">{}}</span>
  <span class="nt">lds_config</span><span class="p">:</span> <span class="p p-Indicator">{</span><span class="nt">ads</span><span class="p">:</span> <span class="p p-Indicator">{}}</span>
  <span class="nt">ads_config</span><span class="p">:</span>
    <span class="nt">api_type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">GRPC</span>
    <span class="nt">grpc_services</span><span class="p">:</span>
      <span class="nt">envoy_grpc</span><span class="p">:</span>
        <span class="nt">cluster_name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ads_cluster</span>
<span class="nt">static_resources</span><span class="p">:</span>
  <span class="nt">clusters</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ads_cluster</span>
    <span class="nt">connect_timeout</span><span class="p">:</span> <span class="p p-Indicator">{</span><span class="nt"> seconds</span><span class="p">:</span> <span class="nv">5</span> <span class="p p-Indicator">}</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">STATIC</span>
    <span class="nt">hosts</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">socket_address</span><span class="p">:</span>
        <span class="nt">address</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;ADS management server IP address&gt;</span>
        <span class="nt">port_value</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;ADS management server port&gt;</span>
    <span class="nt">lb_policy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ROUND_ROBIN</span>
    <span class="c1"># It is recommended to configure either HTTP/2 or TCP keepalives in order to detect</span>
    <span class="c1"># connection issues, and allow Envoy to reconnect. TCP keepalive is less expensive, but</span>
    <span class="c1"># may be inadequate if there is a TCP proxy between Envoy and the management server.</span>
    <span class="c1"># HTTP/2 keepalive is slightly more expensive, but may detect issues through more types</span>
    <span class="c1"># of intermediate proxies.</span>
    <span class="nt">http2_protocol_options</span><span class="p">:</span>
      <span class="nt">connection_keepalive</span><span class="p">:</span>
        <span class="nt">interval</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">30s</span>
        <span class="nt">timeout</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">5s</span>
    <span class="nt">upstream_connection_options</span><span class="p">:</span>
      <span class="nt">tcp_keepalive</span><span class="p">:</span>
        <span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="nt">admin</span><span class="p">:</span>
  <span class="l l-Scalar l-Scalar-Plain">...</span>
</pre></div>
</div>
</div>
<div class="section" id="incremental-xds">
<span id="xds-protocol-delta"></span><h3>Incremental xDS<a class="headerlink" href="#incremental-xds" title="Permalink to this headline">¶</a></h3>
<p>Incremental xDS is a separate xDS endpoint that:</p>
<ul class="simple">
<li><p>Allows the protocol to communicate on the wire in terms of
resource/resource name deltas (“Delta xDS”). This supports the goal
of scalability of xDS resources. Rather than deliver all 100k
clusters when a single cluster is modified, the management server
only needs to deliver the single cluster that changed.</p></li>
<li><p>Allows the Envoy to on-demand / lazily request additional resources.
For example, requesting a cluster only when a request for that
cluster arrives.</p></li>
</ul>
<p>An Incremental xDS session is always in the context of a gRPC
bidirectional stream. This allows the xDS server to keep track of the
state of xDS clients connected to it. There is no REST version of
Incremental xDS yet.</p>
<p>In the delta xDS wire protocol, the nonce field is required and used to
pair a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>
to a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>
ACK or NACK. Optionally, a response message level <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryresponse-system-version-info"><span class="std std-ref">system_version_info</span></a>
is present for debugging purposes only.</p>
<p><a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> can be sent in the following situations:</p>
<ul class="simple">
<li><p>Initial message in a xDS bidirectional gRPC stream.</p></li>
<li><p>As an ACK or NACK response to a previous <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>. In this case the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> is set to the nonce value in the Response. ACK or NACK is determined by the absence or presence of <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a>.</p></li>
<li><p>Spontaneous <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequests</span></a> from the client. This can be done to dynamically add or remove elements from the tracked <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> set. In this case <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> must be omitted.</p></li>
</ul>
<p>In this first example the client connects and receives a first update
that it ACKs. The second update fails and the client NACKs the update.
Later the xDS client spontaneously requests the “wc” resource.</p>
<div class="figure align-default">
<img alt="Incremental session example" src="../_images/incremental.svg" /></div>
<p>On reconnect the Incremental xDS client may tell the server of its known
resources to avoid resending them over the network. Because no state is
assumed to be preserved from the previous stream, the reconnecting
client must provide the server with all resource names it is interested
in.</p>
<div class="figure align-default">
<img alt="Incremental reconnect example" src="../_images/incremental-reconnect.svg" /></div>
<div class="section" id="resource-names">
<h4>Resource names<a class="headerlink" href="#resource-names" title="Permalink to this headline">¶</a></h4>
<p>Resources are identified by a resource name or an alias. Aliases of a
resource, if present, can be identified by the alias field in the
resource of a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>. The resource name will be
returned in the name field in the resource of a
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>.</p>
</div>
<div class="section" id="subscribing-to-resources">
<span id="xds-protocol-delta-subscribe"></span><h4>Subscribing to Resources<a class="headerlink" href="#subscribing-to-resources" title="Permalink to this headline">¶</a></h4>
<p>The client can send either an alias or the name of a resource in the
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> field of a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> in
order to subscribe to a resource. Both the names and aliases of
resources should be checked in order to determine whether the entity in
question has been subscribed to.</p>
<p>A <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> field may contain resource names that the
server believes the client is already subscribed to, and furthermore has
the most recent versions of. However, the server <em>must</em> still provide
those resources in the response; due to implementation details hidden
from the server, the client may have “forgotten” those resources despite
apparently remaining subscribed.</p>
</div>
<div class="section" id="xds-protocol-unsubscribe">
<span id="id1"></span><h4>Unsubscribing from Resources<a class="headerlink" href="#xds-protocol-unsubscribe" title="Permalink to this headline">¶</a></h4>
<p>When a client loses interest in some resources, it will indicate that
with the <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field of a
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>. As with <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a>, these
may be resource names or aliases.</p>
<p>A <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field may contain superfluous resource
names, which the server thought the client was already not subscribed
to. The server must cleanly process such a request; it can simply ignore
these phantom unsubscriptions.</p>
</div>
<div class="section" id="id2">
<h4>Knowing When a Requested Resource Does Not Exist<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>When a resource subscribed to by a client does not exist, the server will send a <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-resource"><span class="std std-ref">Resource</span></a> whose <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-resource-name"><span class="std std-ref">name</span></a> field matches the
name that the client subscribed to and whose <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-field-resource-resource"><span class="std std-ref">resource</span></a>
field is unset. This allows the client to quickly determine when a resource does not exist without
waiting for a timeout, as would be done in the SotW protocol variants. However, clients are still
encouraged to use a timeout to protect against the case where the management server fails to send
a response in a timely manner.</p>
</div>
</div>
</div>
<div class="section" id="rest-json-polling-subscriptions">
<h2>REST-JSON polling subscriptions<a class="headerlink" href="#rest-json-polling-subscriptions" title="Permalink to this headline">¶</a></h2>
<p>Synchronous (long) polling via REST endpoints is also available for the
xDS singleton APIs. The above sequencing of messages is similar, except
no persistent stream is maintained to the management server. It is
expected that there is only a single outstanding request at any point in
time, and as a result the response nonce is optional in REST-JSON. The
<a class="reference external" href="https://developers.google.com/protocol-buffers/docs/proto3#json">JSON canonical transform of
proto3</a>
is used to encode <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
messages. ADS is not available for REST-JSON polling.</p>
<p>When the poll period is set to a small value, with the intention of long
polling, then there is also a requirement to avoid sending a
<a class="reference internal" href="../api-v2/api/v2/discovery.proto.html#envoy-api-msg-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> unless a change to the underlying resources has
occurred via a <a class="reference internal" href="#xds-protocol-resource-update"><span class="std std-ref">resource update</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../api/client_features.html" class="btn btn-neutral float-right" title="Well Known Client Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../api-v3/type/tracing/v3/custom_tag.proto.html" class="btn btn-neutral float-left" title="Custom Tag" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016-2020, Envoy Project Authors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>