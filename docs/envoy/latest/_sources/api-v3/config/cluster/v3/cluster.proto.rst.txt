.. _envoy_v3_api_file_envoy/config/cluster/v3/cluster.proto:

Cluster configuration
=====================



.. _envoy_v3_api_msg_config.cluster.v3.Cluster:

config.cluster.v3.Cluster
-------------------------

`[config.cluster.v3.Cluster proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L44>`_

Configuration for a single upstream cluster.

.. code-block:: json

  {
    "transport_socket_matches": [],
    "name": "...",
    "alt_stat_name": "...",
    "type": "...",
    "cluster_type": "{...}",
    "eds_cluster_config": "{...}",
    "connect_timeout": "{...}",
    "per_connection_buffer_limit_bytes": "{...}",
    "lb_policy": "...",
    "load_assignment": "{...}",
    "health_checks": [],
    "max_requests_per_connection": "{...}",
    "circuit_breakers": "{...}",
    "upstream_http_protocol_options": "{...}",
    "common_http_protocol_options": "{...}",
    "http_protocol_options": "{...}",
    "http2_protocol_options": "{...}",
    "typed_extension_protocol_options": "{...}",
    "dns_refresh_rate": "{...}",
    "dns_failure_refresh_rate": "{...}",
    "respect_dns_ttl": "...",
    "dns_lookup_family": "...",
    "dns_resolvers": [],
    "use_tcp_for_dns_lookups": "...",
    "outlier_detection": "{...}",
    "cleanup_interval": "{...}",
    "upstream_bind_config": "{...}",
    "lb_subset_config": "{...}",
    "ring_hash_lb_config": "{...}",
    "maglev_lb_config": "{...}",
    "original_dst_lb_config": "{...}",
    "least_request_lb_config": "{...}",
    "common_lb_config": "{...}",
    "transport_socket": "{...}",
    "metadata": "{...}",
    "protocol_selection": "...",
    "upstream_connection_options": "{...}",
    "close_connections_on_host_health_failure": "...",
    "ignore_health_on_host_removal": "...",
    "filters": [],
    "track_timeout_budgets": "...",
    "upstream_config": "{...}",
    "track_cluster_stats": "{...}",
    "preconnect_policy": "{...}",
    "connection_pool_per_downstream_connection": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches:

transport_socket_matches
  (**repeated** :ref:`config.cluster.v3.Cluster.TransportSocketMatch <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`) Configuration to use different transport sockets for different endpoints.
  The entry of *envoy.transport_socket_match* in the
  :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`
  is used to match against the transport sockets as they appear in the list. The first
  :ref:`match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
  For example, with the following match
  
  .. code-block:: yaml
  
   transport_socket_matches:
   - name: "enableMTLS"
     match:
       acceptMTLS: true
     transport_socket:
       name: envoy.transport_sockets.tls
       config: { ... } # tls socket configuration
   - name: "defaultToPlaintext"
     match: {}
     transport_socket:
       name: envoy.transport_sockets.raw_buffer
  
  Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
  having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
  
  If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
  criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
  socket match in case above.
  
  If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
  *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
  *transport_socket* specified in this cluster.
  
  This field allows gradual and flexible transport socket configuration changes.
  
  The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
  an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
  "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
  has "acceptPlaintext": "true" metadata information.
  
  Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
  traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
  *TransportSocketMatch* in this field. Other client Envoys receive CDS without
  *transport_socket_match* set, and still send plain text traffic to the same cluster.
  
  This field can be used to specify custom transport socket configurations for health
  checks by adding matching key/value pairs in a health check's
  :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
  
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.name:

name
  (`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_, *REQUIRED*) Supplies the name of the cluster which must be unique across all clusters.
  The cluster name is used when emitting
  :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
  <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
  Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name:

alt_stat_name
  (`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) An optional alternative to the cluster name to be used for observability. This name is used
  emitting stats for the cluster and access logging the cluster name. This will appear as
  additional information in configuration dumps of a cluster's current status as
  :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
  and as an additional tag "upstream_cluster.name" while tracing. Note: access logging using
  this field is presently enabled with runtime feature
  `envoy.reloadable_features.use_observable_cluster_name`. Any ``:`` in the name will be
  converted to ``_`` when emitting statistics. This should not be confused with :ref:`Router
  Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.type:

type
  (:ref:`config.cluster.v3.Cluster.DiscoveryType <envoy_v3_api_enum_config.cluster.v3.Cluster.DiscoveryType>`) The :ref:`service discovery type <arch_overview_service_discovery_types>`
  to use for resolving the cluster.
  
  
  
  Only one of :ref:`type <envoy_v3_api_field_config.cluster.v3.Cluster.type>`, :ref:`cluster_type <envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type:

cluster_type
  (:ref:`config.cluster.v3.Cluster.CustomClusterType <envoy_v3_api_msg_config.cluster.v3.Cluster.CustomClusterType>`) The custom cluster type.
  
  
  
  Only one of :ref:`type <envoy_v3_api_field_config.cluster.v3.Cluster.type>`, :ref:`cluster_type <envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.eds_cluster_config:

eds_cluster_config
  (:ref:`config.cluster.v3.Cluster.EdsClusterConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.EdsClusterConfig>`) Configuration to use for EDS updates for the Cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.connect_timeout:

connect_timeout
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_) The timeout for new network connections to hosts in the cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.per_connection_buffer_limit_bytes:

per_connection_buffer_limit_bytes
  (`UInt32Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint32value>`_) Soft limit on size of the cluster’s connections read and write buffers. If
  unspecified, an implementation defined default is applied (1MiB).
  
  .. attention::
    This field should be configured in the presence of untrusted *upstreams*.

    Example configuration for untrusted environments:

    .. code-block:: yaml

      per_connection_buffer_limit_bytes: 32768.0
      
.. _envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy:

lb_policy
  (:ref:`config.cluster.v3.Cluster.LbPolicy <envoy_v3_api_enum_config.cluster.v3.Cluster.LbPolicy>`) The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
  when picking a host in the cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.load_assignment:

load_assignment
  (:ref:`config.endpoint.v3.ClusterLoadAssignment <envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`) Setting this is required for specifying members of
  :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
  This field supersedes the *hosts* field in the v2 API.
  
  .. attention::
  
    Setting this allows non-EDS cluster types to contain embedded EDS equivalent
    :ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
  
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.health_checks:

health_checks
  (**repeated** :ref:`config.core.v3.HealthCheck <envoy_v3_api_msg_config.core.v3.HealthCheck>`) Optional :ref:`active health checking <arch_overview_health_checking>`
  configuration for the cluster. If no
  configuration is specified no health checking will be done and all cluster
  members will be considered healthy at all times.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.max_requests_per_connection:

max_requests_per_connection
  (`UInt32Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint32value>`_) Optional maximum requests for a single upstream connection. This parameter
  is respected by both the HTTP/1.1 and HTTP/2 connection pool
  implementations. If not specified, there is no limit. Setting this
  parameter to 1 will effectively disable keep alive.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.circuit_breakers:

circuit_breakers
  (:ref:`config.cluster.v3.CircuitBreakers <envoy_v3_api_msg_config.cluster.v3.CircuitBreakers>`) Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.upstream_http_protocol_options:

upstream_http_protocol_options
  (:ref:`config.core.v3.UpstreamHttpProtocolOptions <envoy_v3_api_msg_config.core.v3.UpstreamHttpProtocolOptions>`) HTTP protocol options that are applied only to upstream HTTP connections.
  These options apply to all HTTP versions.
  This has been deprecated in favor of
  :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  upstream_http_protocol_options can be set via the cluster's
  :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  See ref:`upstream_http_protocol_options
  <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  for example usage.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.common_http_protocol_options:

common_http_protocol_options
  (:ref:`config.core.v3.HttpProtocolOptions <envoy_v3_api_msg_config.core.v3.HttpProtocolOptions>`) Additional options when handling HTTP requests upstream. These options will be applicable to
  both HTTP1 and HTTP2 requests.
  This has been deprecated in favor of
  :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
  in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  common_http_protocol_options can be set via the cluster's
  :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  See ref:`upstream_http_protocol_options
  <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  for example usage.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.http_protocol_options:

http_protocol_options
  (:ref:`config.core.v3.Http1ProtocolOptions <envoy_v3_api_msg_config.core.v3.Http1ProtocolOptions>`) Additional options when handling HTTP1 requests.
  This has been deprecated in favor of http_protocol_options fields in the in the
  :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  http_protocol_options can be set via the cluster's
  :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  See ref:`upstream_http_protocol_options
  <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  for example usage.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options:

http2_protocol_options
  (:ref:`config.core.v3.Http2ProtocolOptions <envoy_v3_api_msg_config.core.v3.Http2ProtocolOptions>`) Even if default HTTP2 protocol options are desired, this field must be
  set so that Envoy will assume that the upstream supports HTTP/2 when
  making new HTTP connection pool connections. Currently, Envoy only
  supports prior knowledge for upstream connections. Even if TLS is used
  with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
  connections to happen over plain text.
  This has been deprecated in favor of http2_protocol_options fields in the in the
  :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
  message. http2_protocol_options can be set via the cluster's
  :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  See ref:`upstream_http_protocol_options
  <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  for example usage.
  
  .. attention::
    This field should be configured in the presence of untrusted *upstreams*.

    Example configuration for untrusted environments:

    .. code-block:: yaml

      http2_protocol_options:
        initial_connection_window_size: 1048576.0
        initial_stream_window_size: 65536.0
      
.. _envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options:

typed_extension_protocol_options
  (**repeated** map<`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_, `Any <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#any>`_>) The extension_protocol_options field is used to provide extension-specific protocol options
  for upstream connections. The key should match the extension filter name, such as
  "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
  specific options.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.dns_refresh_rate:

dns_refresh_rate
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_) If the DNS refresh rate is specified and the cluster type is either
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  this value is used as the cluster’s DNS refresh
  rate. The value configured must be at least 1ms. If this setting is not specified, the
  value defaults to 5000ms. For cluster types other than
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  this setting is ignored.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.dns_failure_refresh_rate:

dns_failure_refresh_rate
  (:ref:`config.cluster.v3.Cluster.RefreshRate <envoy_v3_api_msg_config.cluster.v3.Cluster.RefreshRate>`) If the DNS failure refresh rate is specified and the cluster type is either
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
  not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
  other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
  :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
  ignored.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.respect_dns_ttl:

respect_dns_ttl
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
  cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
  resolution.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.dns_lookup_family:

dns_lookup_family
  (:ref:`config.cluster.v3.Cluster.DnsLookupFamily <envoy_v3_api_enum_config.cluster.v3.Cluster.DnsLookupFamily>`) The DNS IP address resolution policy. If this setting is not specified, the
  value defaults to
  :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers:

dns_resolvers
  (**repeated** :ref:`config.core.v3.Address <envoy_v3_api_msg_config.core.v3.Address>`) If DNS resolvers are specified and the cluster type is either
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  this value is used to specify the cluster’s dns resolvers.
  If this setting is not specified, the value defaults to the default
  resolver, which uses /etc/resolv.conf for configuration. For cluster types
  other than
  :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  this setting is ignored.
  Setting this value causes failure if the
  ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  server startup. Apple's API only allows overriding DNS resolvers via system settings.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups:

use_tcp_for_dns_lookups
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) Always use TCP queries instead of UDP queries for DNS lookups.
  Setting this value causes failure if the
  ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  server startup. Apple' API only uses UDP for DNS resolution.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.outlier_detection:

outlier_detection
  (:ref:`config.cluster.v3.OutlierDetection <envoy_v3_api_msg_config.cluster.v3.OutlierDetection>`) If specified, outlier detection will be enabled for this upstream cluster.
  Each of the configuration values can be overridden via
  :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.cleanup_interval:

cleanup_interval
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_) The interval for removing stale hosts from a cluster type
  :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
  Hosts are considered stale if they have not been used
  as upstream destinations during this interval. New hosts are added
  to original destination clusters on demand as new connections are
  redirected to Envoy, causing the number of hosts in the cluster to
  grow over time. Hosts that are not stale (they are actively used as
  destinations) are kept in the cluster, which allows connections to
  them remain open, saving the latency that would otherwise be spent
  on opening new connections. If this setting is not specified, the
  value defaults to 5000ms. For cluster types other than
  :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
  this setting is ignored.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.upstream_bind_config:

upstream_bind_config
  (:ref:`config.core.v3.BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`) Optional configuration used to bind newly established upstream connections.
  This overrides any bind_config specified in the bootstrap proto.
  If the address and port are empty, no bind will be performed.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.lb_subset_config:

lb_subset_config
  (:ref:`config.cluster.v3.Cluster.LbSubsetConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.LbSubsetConfig>`) Configuration for load balancing subsetting.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.ring_hash_lb_config:

ring_hash_lb_config
  (:ref:`config.cluster.v3.Cluster.RingHashLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.RingHashLbConfig>`) Optional configuration for the Ring Hash load balancing policy.
  
  Optional configuration for the load balancing algorithm selected by
  LbPolicy. Currently only
  :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
  :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
  :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  has additional configuration options.
  Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
  LbPolicy will generate an error at runtime.
  
  
  Only one of :ref:`ring_hash_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.ring_hash_lb_config>`, :ref:`maglev_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.maglev_lb_config>`, :ref:`original_dst_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.original_dst_lb_config>`, :ref:`least_request_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.maglev_lb_config:

maglev_lb_config
  (:ref:`config.cluster.v3.Cluster.MaglevLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.MaglevLbConfig>`) Optional configuration for the Maglev load balancing policy.
  
  Optional configuration for the load balancing algorithm selected by
  LbPolicy. Currently only
  :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
  :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
  :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  has additional configuration options.
  Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
  LbPolicy will generate an error at runtime.
  
  
  Only one of :ref:`ring_hash_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.ring_hash_lb_config>`, :ref:`maglev_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.maglev_lb_config>`, :ref:`original_dst_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.original_dst_lb_config>`, :ref:`least_request_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.original_dst_lb_config:

original_dst_lb_config
  (:ref:`config.cluster.v3.Cluster.OriginalDstLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.OriginalDstLbConfig>`) Optional configuration for the Original Destination load balancing policy.
  
  Optional configuration for the load balancing algorithm selected by
  LbPolicy. Currently only
  :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
  :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
  :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  has additional configuration options.
  Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
  LbPolicy will generate an error at runtime.
  
  
  Only one of :ref:`ring_hash_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.ring_hash_lb_config>`, :ref:`maglev_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.maglev_lb_config>`, :ref:`original_dst_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.original_dst_lb_config>`, :ref:`least_request_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config:

least_request_lb_config
  (:ref:`config.cluster.v3.Cluster.LeastRequestLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.LeastRequestLbConfig>`) Optional configuration for the LeastRequest load balancing policy.
  
  Optional configuration for the load balancing algorithm selected by
  LbPolicy. Currently only
  :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
  :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
  :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  has additional configuration options.
  Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
  LbPolicy will generate an error at runtime.
  
  
  Only one of :ref:`ring_hash_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.ring_hash_lb_config>`, :ref:`maglev_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.maglev_lb_config>`, :ref:`original_dst_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.original_dst_lb_config>`, :ref:`least_request_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.common_lb_config:

common_lb_config
  (:ref:`config.cluster.v3.Cluster.CommonLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig>`) Common configuration for all load balancer implementations.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket:

transport_socket
  (:ref:`config.core.v3.TransportSocket <envoy_v3_api_msg_config.core.v3.TransportSocket>`) Optional custom transport socket implementation to use for upstream connections.
  To setup TLS, set a transport socket with name `tls` and
  :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the `typed_config`.
  If no transport socket configuration is specified, new connections
  will be set up with plaintext.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.metadata:

metadata
  (:ref:`config.core.v3.Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`) The Metadata field can be used to provide additional information about the
  cluster. It can be used for stats, logging, and varying filter behavior.
  Fields should use reverse DNS notation to denote which entity within Envoy
  will need the information. For instance, if the metadata is intended for
  the Router filter, the filter name should be specified as *envoy.filters.http.router*.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.protocol_selection:

protocol_selection
  (:ref:`config.cluster.v3.Cluster.ClusterProtocolSelection <envoy_v3_api_enum_config.cluster.v3.Cluster.ClusterProtocolSelection>`) Determines how Envoy selects the protocol used to speak to upstream hosts.
  This has been deprecated in favor of setting explicit protocol selection
  in the :ref:`http_protocol_options
  <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  http_protocol_options can be set via the cluster's
  :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.upstream_connection_options:

upstream_connection_options
  (:ref:`config.cluster.v3.UpstreamConnectionOptions <envoy_v3_api_msg_config.cluster.v3.UpstreamConnectionOptions>`) Optional options for upstream connections.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.close_connections_on_host_health_failure:

close_connections_on_host_health_failure
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If an upstream host becomes unhealthy (as determined by the configured health checks
  or outlier detection), immediately close all connections to the failed host.
  
  .. note::
  
    This is currently only supported for connections created by tcp_proxy.
  
  .. note::
  
    The current implementation of this feature closes all connections immediately when
    the unhealthy status is detected. If there are a large number of connections open
    to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
    time exclusively closing these connections, and not processing any other traffic.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.ignore_health_on_host_removal:

ignore_health_on_host_removal
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If set to true, Envoy will ignore the health value of a host when processing its removal
  from service discovery. This means that if active health checking is used, Envoy will *not*
  wait for the endpoint to go unhealthy before removing it.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.filters:

filters
  (**repeated** :ref:`config.cluster.v3.Filter <envoy_v3_api_msg_config.cluster.v3.Filter>`) An (optional) network filter chain, listed in the order the filters should be applied.
  The chain will be applied to all outgoing connections that Envoy makes to the upstream
  servers of this cluster.
  
  


.. _envoy_v3_api_field_config.cluster.v3.Cluster.track_timeout_budgets:

track_timeout_budgets
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If track_timeout_budgets is true, the :ref:`timeout budget histograms
  <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
  request. These show what percentage of a request's per try and global timeout was used. A value
  of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
  of 100 would indicate that the request took the entirety of the timeout given to it.
  
  .. attention::
  
    This field has been deprecated in favor of `timeout_budgets`, part of
    :ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.upstream_config:

upstream_config
  (:ref:`config.core.v3.TypedExtensionConfig <envoy_v3_api_msg_config.core.v3.TypedExtensionConfig>`) Optional customization and configuration of upstream connection pool, and upstream type.
  
  Currently this field only applies for HTTP traffic but is designed for eventual use for custom
  TCP upstreams.
  
  For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
  HTTP, using the http connection pool and the codec from `http2_protocol_options`
  
  For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
  requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
  
  The default pool used is the generic connection pool which creates the HTTP upstream for most
  HTTP requests, and the TCP upstream if CONNECT termination is configured.
  
  If users desire custom connection pool or upstream behavior, for example terminating
  CONNECT only if a custom filter indicates it is appropriate, the custom factories
  can be registered and configured here.
  
  
  .. _extension_category_envoy.upstreams:
  
  .. tip::
    This extension category has the following known extensions:
  
  
    - :ref:`envoy.upstreams.http.generic <extension_envoy.upstreams.http.generic>`
  
    - :ref:`envoy.upstreams.http.http <extension_envoy.upstreams.http.http>`
  
    - :ref:`envoy.upstreams.http.http_protocol_options <extension_envoy.upstreams.http.http_protocol_options>`
  
    - :ref:`envoy.upstreams.http.tcp <extension_envoy.upstreams.http.tcp>`
  
    - :ref:`envoy.upstreams.tcp.generic <extension_envoy.upstreams.tcp.generic>`
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats:

track_cluster_stats
  (:ref:`config.cluster.v3.TrackClusterStats <envoy_v3_api_msg_config.cluster.v3.TrackClusterStats>`) Configuration to track optional cluster stats.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.preconnect_policy:

preconnect_policy
  (:ref:`config.cluster.v3.Cluster.PreconnectPolicy <envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy>`) Preconnect configuration for this cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.connection_pool_per_downstream_connection:

connection_pool_per_downstream_connection
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
  connection pool for every downstream connection
  
  
.. _envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch:

config.cluster.v3.Cluster.TransportSocketMatch
----------------------------------------------

`[config.cluster.v3.Cluster.TransportSocketMatch proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L146>`_

TransportSocketMatch specifies what transport socket config will be used
when the match conditions are satisfied.

.. code-block:: json

  {
    "name": "...",
    "match": "{...}",
    "transport_socket": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.TransportSocketMatch.name:

name
  (`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_, *REQUIRED*) The name of the match, used in stats generation.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.TransportSocketMatch.match:

match
  (`Struct <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct>`_) Optional endpoint metadata match criteria.
  The connection to the endpoint with metadata matching what is set in this field
  will use the transport socket configuration specified here.
  The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
  against the values specified in this field.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.TransportSocketMatch.transport_socket:

transport_socket
  (:ref:`config.core.v3.TransportSocket <envoy_v3_api_msg_config.core.v3.TransportSocket>`) The configuration of the transport socket.
  
  
  .. _extension_category_envoy.transport_sockets.upstream:
  
  .. tip::
    This extension category has the following known extensions:
  
  
    - :ref:`envoy.transport_sockets.alts <extension_envoy.transport_sockets.alts>`
  
    - :ref:`envoy.transport_sockets.raw_buffer <extension_envoy.transport_sockets.raw_buffer>`
  
    - :ref:`envoy.transport_sockets.starttls <extension_envoy.transport_sockets.starttls>`
  
    - :ref:`envoy.transport_sockets.tap <extension_envoy.transport_sockets.tap>`
  
    - :ref:`envoy.transport_sockets.tls <extension_envoy.transport_sockets.tls>`
  
    - :ref:`envoy.transport_sockets.upstream_proxy_protocol <extension_envoy.transport_sockets.upstream_proxy_protocol>`
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.CustomClusterType:

config.cluster.v3.Cluster.CustomClusterType
-------------------------------------------

`[config.cluster.v3.Cluster.CustomClusterType proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L166>`_

Extended cluster type.

.. code-block:: json

  {
    "name": "...",
    "typed_config": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.CustomClusterType.name:

name
  (`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_, *REQUIRED*) The type of the cluster to instantiate. The name must match a supported cluster type.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CustomClusterType.typed_config:

typed_config
  (`Any <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#any>`_) Cluster specific configuration which depends on the cluster being instantiated.
  See the supported cluster for further documentation.
  
  
  .. _extension_category_envoy.clusters:
  
  .. tip::
    This extension category has the following known extensions:
  
  
    - :ref:`envoy.clusters.aggregate <extension_envoy.clusters.aggregate>`
  
    - :ref:`envoy.clusters.dynamic_forward_proxy <extension_envoy.clusters.dynamic_forward_proxy>`
  
    - :ref:`envoy.clusters.redis <extension_envoy.clusters.redis>`
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.EdsClusterConfig:

config.cluster.v3.Cluster.EdsClusterConfig
------------------------------------------

`[config.cluster.v3.Cluster.EdsClusterConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L180>`_

Only valid when discovery type is EDS.

.. code-block:: json

  {
    "eds_config": "{...}",
    "service_name": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.eds_config:

eds_config
  (:ref:`config.core.v3.ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>`) Configuration for the source of EDS updates for this Cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name:

service_name
  (`string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) Optional alternative to cluster name to present to EDS. This does not
  have the same restrictions as cluster name, i.e. it may be arbitrary
  length. This may be a xdstp:// URL.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.LbSubsetConfig:

config.cluster.v3.Cluster.LbSubsetConfig
----------------------------------------

`[config.cluster.v3.Cluster.LbSubsetConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L196>`_

Optionally divide the endpoints in this cluster into subsets defined by
endpoint metadata and selected by route and weighted cluster metadata.

.. code-block:: json

  {
    "fallback_policy": "...",
    "default_subset": "{...}",
    "subset_selectors": [],
    "locality_weight_aware": "...",
    "scale_locality_weight": "...",
    "panic_mode_any": "...",
    "list_as_any": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy:

fallback_policy
  (:ref:`config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy <envoy_v3_api_enum_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy>`) The behavior used when no endpoint subset matches the selected route's
  metadata. The value defaults to
  :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.default_subset:

default_subset
  (`Struct <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct>`_) Specifies the default subset of endpoints used during fallback if
  fallback_policy is
  :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
  Each field in default_subset is
  compared to the matching LbEndpoint.Metadata under the *envoy.lb*
  namespace. It is valid for no hosts to match, in which case the behavior
  is the same as a fallback_policy of
  :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.subset_selectors:

subset_selectors
  (**repeated** :ref:`config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector <envoy_v3_api_msg_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector>`) For each entry, LbEndpoint.Metadata's
  *envoy.lb* namespace is traversed and a subset is created for each unique
  combination of key and value. For example:
  
  .. code-block:: json
  
    { "subset_selectors": [
        { "keys": [ "version" ] },
        { "keys": [ "stage", "hardware_type" ] }
    ]}
  
  A subset is matched when the metadata from the selected route and
  weighted cluster contains the same keys and values as the subset's
  metadata. The same host may appear in multiple subsets.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.locality_weight_aware:

locality_weight_aware
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If true, routing to subsets will take into account the localities and locality weights of the
  endpoints when making the routing decision.
  
  There are some potential pitfalls associated with enabling this feature, as the resulting
  traffic split after applying both a subset match and locality weights might be undesirable.
  
  Consider for example a situation in which you have 50/50 split across two localities X/Y
  which have 100 hosts each without subsetting. If the subset LB results in X having only 1
  host selected but Y having 100, then a lot more load is being dumped on the single host in X
  than originally anticipated in the load balancing assignment delivered via EDS.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.scale_locality_weight:

scale_locality_weight
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) When used with locality_weight_aware, scales the weight of each locality by the ratio
  of hosts in the subset vs hosts in the original subset. This aims to even out the load
  going to an individual locality if said locality is disproportionately affected by the
  subset predicate.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.panic_mode_any:

panic_mode_any
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If true, when a fallback policy is configured and its corresponding subset fails to find
  a host this will cause any host to be selected instead.
  
  This is useful when using the default subset as the fallback policy, given the default
  subset might become empty. With this option enabled, if that happens the LB will attempt
  to select a host from the entire cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.list_as_any:

list_as_any
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If true, metadata specified for a metadata key will be matched against the corresponding
  endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
  and any of the elements in the list matches the criteria.
  
  
.. _envoy_v3_api_msg_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector:

config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
---------------------------------------------------------

`[config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L212>`_

Specifications for subsets.

.. code-block:: json

  {
    "keys": [],
    "single_host_per_subset": "...",
    "fallback_policy": "...",
    "fallback_keys_subset": []
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys:

keys
  (**repeated** `string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) List of keys to match with the weighted cluster metadata.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.single_host_per_subset:

single_host_per_subset
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
  choosing a host, but updating hosts is faster, especially for large numbers of hosts.
  
  If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
  
  Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
  only one entry.
  
  When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
  will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
  :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
  present in the current configuration.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_policy:

fallback_policy
  (:ref:`config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy <envoy_v3_api_enum_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy>`) The behavior used when no endpoint subset matches the selected route's
  metadata.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset:

fallback_keys_subset
  (**repeated** `string <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) Subset of
  :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
  :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
  fallback policy.
  It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
  For any other fallback policy the parameter is not used and should not be set.
  Only values also present in
  :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
  `fallback_keys_subset` cannot be equal to `keys`.
  
  

.. _envoy_v3_api_enum_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy:

Enum config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
---------------------------------------------------------------------------------------------

`[config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L217>`_

Allows to override top level fallback policy per selector.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.NOT_DEFINED:

NOT_DEFINED
  *(DEFAULT)* ⁣If NOT_DEFINED top level config fallback policy is used instead.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.NO_FALLBACK:

NO_FALLBACK
  ⁣If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:

ANY_ENDPOINT
  ⁣If ANY_ENDPOINT is selected, any cluster endpoint may be returned
  (subject to policy, health checks, etc).
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:

DEFAULT_SUBSET
  ⁣If DEFAULT_SUBSET is selected, load balancing is performed over the
  endpoints matching the values from the default_subset field.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:

KEYS_SUBSET
  ⁣If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
  keys reduced to
  :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
  It allows for a fallback to a different, less specific selector if some of the keys of
  the selector are considered optional.
  
  

.. _envoy_v3_api_enum_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy:

Enum config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
--------------------------------------------------------------------

`[config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L205>`_

If NO_FALLBACK is selected, a result
equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
any cluster endpoint may be returned (subject to policy, health checks,
etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
endpoints matching the values from the default_subset field.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK:

NO_FALLBACK
  *(DEFAULT)* ⁣
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.ANY_ENDPOINT:

ANY_ENDPOINT
  ⁣
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET:

DEFAULT_SUBSET
  ⁣
  

.. _envoy_v3_api_msg_config.cluster.v3.Cluster.LeastRequestLbConfig:

config.cluster.v3.Cluster.LeastRequestLbConfig
----------------------------------------------

`[config.cluster.v3.Cluster.LeastRequestLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L338>`_

Specific configuration for the LeastRequest load balancing policy.

.. code-block:: json

  {
    "choice_count": "{...}",
    "active_request_bias": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.LeastRequestLbConfig.choice_count:

choice_count
  (`UInt32Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint32value>`_) The number of random healthy hosts from which the host with the fewest active requests will
  be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.LeastRequestLbConfig.active_request_bias:

active_request_bias
  (:ref:`config.core.v3.RuntimeDouble <envoy_v3_api_msg_config.core.v3.RuntimeDouble>`) The following formula is used to calculate the dynamic weights when hosts have different load
  balancing weights:
  
  `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
  
  The larger the active request bias is, the more aggressively active requests will lower the
  effective weight when all host weights are not equal.
  
  `active_request_bias` must be greater than or equal to 0.0.
  
  When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
  of active requests at the time it picks a host and behaves like the Round Robin Load
  Balancer.
  
  When `active_request_bias > 0.0` the Least Request Load Balancer scales the load balancing
  weight by the number of active requests at the time it does a pick.
  
  The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
  host sets changes, e.g., whenever there is a host membership update or a host load balancing
  weight change.
  
  .. note::
    This setting only takes effect if all host weights are not equal.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.RingHashLbConfig:

config.cluster.v3.Cluster.RingHashLbConfig
------------------------------------------

`[config.cluster.v3.Cluster.RingHashLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L374>`_

Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
load balancing policy.

.. code-block:: json

  {
    "minimum_ring_size": "{...}",
    "hash_function": "...",
    "maximum_ring_size": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size:

minimum_ring_size
  (`UInt64Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint64value>`_) Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
  provided host) the better the request distribution will reflect the desired weights. Defaults
  to 1024 entries, and limited to 8M entries. See also
  :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.hash_function:

hash_function
  (:ref:`config.cluster.v3.Cluster.RingHashLbConfig.HashFunction <envoy_v3_api_enum_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction>`) The hash function used to hash hosts onto the ketama ring. The value defaults to
  :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size:

maximum_ring_size
  (`UInt64Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint64value>`_) Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
  to further constrain resource use. See also
  :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
  
  

.. _envoy_v3_api_enum_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction:

Enum config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
------------------------------------------------------------

`[config.cluster.v3.Cluster.RingHashLbConfig.HashFunction proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L379>`_

The hash function used to hash hosts onto the ketama ring.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH:

XX_HASH
  *(DEFAULT)* ⁣Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.MURMUR_HASH_2:

MURMUR_HASH_2
  ⁣Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
  std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
  on Linux and not macOS.
  
  

.. _envoy_v3_api_msg_config.cluster.v3.Cluster.MaglevLbConfig:

config.cluster.v3.Cluster.MaglevLbConfig
----------------------------------------

`[config.cluster.v3.Cluster.MaglevLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L409>`_

Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
load balancing policy.

.. code-block:: json

  {
    "table_size": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.MaglevLbConfig.table_size:

table_size
  (`UInt64Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint64value>`_) The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
  Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
  upstream as it was before. Increasing the table size reduces the amount of disruption.
  The table size must be prime number. If it is not specified, the default is 65537.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.OriginalDstLbConfig:

config.cluster.v3.Cluster.OriginalDstLbConfig
---------------------------------------------

`[config.cluster.v3.Cluster.OriginalDstLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L420>`_

Specific configuration for the
:ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
load balancing policy.

.. code-block:: json

  {
    "use_http_header": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header:

use_http_header
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) When true, :ref:`x-envoy-original-dst-host
  <config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
  address.
  
  .. attention::
  
    This header isn't sanitized by default, so enabling this feature allows HTTP clients to
    route traffic to arbitrary hosts and/or ports, which may have serious security
    consequences.
  
  .. note::
  
    If the header appears multiple times only the first value is used.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig:

config.cluster.v3.Cluster.CommonLbConfig
----------------------------------------

`[config.cluster.v3.Cluster.CommonLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L442>`_

Common configuration for all load balancer implementations.

.. code-block:: json

  {
    "healthy_panic_threshold": "{...}",
    "zone_aware_lb_config": "{...}",
    "locality_weighted_lb_config": "{...}",
    "update_merge_window": "{...}",
    "ignore_new_hosts_until_first_hc": "...",
    "close_connections_on_host_set_change": "...",
    "consistent_hashing_lb_config": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.healthy_panic_threshold:

healthy_panic_threshold
  (:ref:`type.v3.Percent <envoy_v3_api_msg_type.v3.Percent>`) Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
  If not specified, the default is 50%.
  To disable panic mode, set to 0%.
  
  .. note::
    The specified percent will be truncated to the nearest 1%.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.zone_aware_lb_config:

zone_aware_lb_config
  (:ref:`config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig>`) 
  
  
  Only one of :ref:`zone_aware_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.zone_aware_lb_config>`, :ref:`locality_weighted_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.locality_weighted_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.locality_weighted_lb_config:

locality_weighted_lb_config
  (:ref:`config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig>`) 
  
  
  Only one of :ref:`zone_aware_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.zone_aware_lb_config>`, :ref:`locality_weighted_lb_config <envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.locality_weighted_lb_config>` may be set.
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.update_merge_window:

update_merge_window
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_) If set, all health check/weight/metadata updates that happen within this duration will be
  merged and delivered in one shot when the duration expires. The start of the duration is when
  the first update happens. This is useful for big clusters, with potentially noisy deploys
  that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
  or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
  cluster). Please always keep in mind that the use of sandbox technologies may change this
  behavior.
  
  If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
  window to 0.
  
  Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
  because merging those updates isn't currently safe. See
  https://github.com/envoyproxy/envoy/pull/3941.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ignore_new_hosts_until_first_hc:

ignore_new_hosts_until_first_hc
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
  when computing load balancing weights until they have been health checked for the first time.
  This will have no effect unless active health checking is also configured.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.close_connections_on_host_set_change:

close_connections_on_host_set_change
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If set to `true`, the cluster manager will drain all existing
  connections to upstream hosts whenever hosts are added or removed from the cluster.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.consistent_hashing_lb_config:

consistent_hashing_lb_config
  (:ref:`config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig>`) Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
  
  
.. _envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig:

config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
----------------------------------------------------------

`[config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L448>`_

Configuration for :ref:`zone aware routing
<arch_overview_load_balancing_zone_aware_routing>`.

.. code-block:: json

  {
    "routing_enabled": "{...}",
    "min_cluster_size": "{...}",
    "fail_traffic_on_panic": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.routing_enabled:

routing_enabled
  (:ref:`type.v3.Percent <envoy_v3_api_msg_type.v3.Percent>`) Configures percentage of requests that will be considered for zone aware routing
  if zone aware routing is configured. If not specified, the default is 100%.
  * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
  * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.min_cluster_size:

min_cluster_size
  (`UInt64Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint64value>`_) Configures minimum upstream cluster size required for zone aware routing
  If upstream cluster size is less than specified, zone aware routing is not performed
  even if zone aware routing is configured. If not specified, the default is 6.
  * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
  * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.fail_traffic_on_panic:

fail_traffic_on_panic
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
  mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
  requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
  failing service.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig:

config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
-----------------------------------------------------------------

`[config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L474>`_

Configuration for :ref:`locality weighted load balancing
<arch_overview_load_balancing_locality_weighted_lb>`

.. code-block:: json

  {}




.. _envoy_v3_api_msg_config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig:

config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
------------------------------------------------------------------

`[config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L480>`_

Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)

.. code-block:: json

  {
    "use_hostname_for_hashing": "...",
    "hash_balance_factor": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.use_hostname_for_hashing:

use_hostname_for_hashing
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If set to `true`, the cluster will use hostname instead of the resolved
  address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.hash_balance_factor:

hash_balance_factor
  (`UInt32Value <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#uint32value>`_) Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
  no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
  If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
  Minimum is 100.
  
  Applies to both Ring Hash and Maglev load balancers.
  
  This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
  `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
  across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
  is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
  the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
  cascading overflow effect when choosing the next host in the ring/table).
  
  If weights are specified on the hosts, they are respected.
  
  This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
  being probed, so use a higher value if you require better performance.
  
  



.. _envoy_v3_api_msg_config.cluster.v3.Cluster.RefreshRate:

config.cluster.v3.Cluster.RefreshRate
-------------------------------------

`[config.cluster.v3.Cluster.RefreshRate proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L552>`_


.. code-block:: json

  {
    "base_interval": "{...}",
    "max_interval": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval:

base_interval
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_, *REQUIRED*) Specifies the base interval between refreshes. This parameter is required and must be greater
  than zero and less than
  :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval:

max_interval
  (`Duration <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration>`_) Specifies the maximum interval between refreshes. This parameter is optional, but must be
  greater than or equal to the
  :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
  is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy:

config.cluster.v3.Cluster.PreconnectPolicy
------------------------------------------

`[config.cluster.v3.Cluster.PreconnectPolicy proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L570>`_


.. code-block:: json

  {
    "per_upstream_preconnect_ratio": "{...}",
    "predictive_preconnect_ratio": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.Cluster.PreconnectPolicy.per_upstream_preconnect_ratio:

per_upstream_preconnect_ratio
  (`DoubleValue <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#doublevalue>`_) Indicates how many streams (rounded up) can be anticipated per-upstream for each
  incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
  will only be done if the upstream is healthy and the cluster has traffic.
  
  For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
  established, one for the new incoming stream, and one for a presumed follow-up stream. For
  HTTP/2, only one connection would be established by default as one connection can
  serve both the original and presumed follow-up stream.
  
  In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
  active streams, there would be 100 connections in use, and 50 connections preconnected.
  This might be a useful value for something like short lived single-use connections,
  for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
  termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
  or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
  reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
  in case of unexpected disconnects where the connection could not be reused.
  
  If this value is not set, or set explicitly to one, Envoy will fetch as many connections
  as needed to serve streams in flight. This means in steady state if a connection is torn down,
  a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
  
  This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
  harm latency more than the preconnecting helps.
  
  
.. _envoy_v3_api_field_config.cluster.v3.Cluster.PreconnectPolicy.predictive_preconnect_ratio:

predictive_preconnect_ratio
  (`DoubleValue <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#doublevalue>`_) Indicates how many many streams (rounded up) can be anticipated across a cluster for each
  stream, useful for low QPS services. This is currently supported for a subset of
  deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
  Unlike *per_upstream_preconnect_ratio* this preconnects across the upstream instances in a
  cluster, doing best effort predictions of what upstream would be picked next and
  pre-establishing a connection.
  
  Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
  only be done if there are healthy upstreams and the cluster has traffic.
  
  For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
  incoming stream, 2 connections will be preconnected - one to the first upstream for this
  cluster, one to the second on the assumption there will be a follow-up stream.
  
  If this value is not set, or set explicitly to one, Envoy will fetch as many connections
  as needed to serve streams in flight, so during warm up and in steady state if a connection
  is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
  connection establishment.
  
  If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
  basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
  upstream.
  
  



.. _envoy_v3_api_enum_config.cluster.v3.Cluster.DiscoveryType:

Enum config.cluster.v3.Cluster.DiscoveryType
--------------------------------------------

`[config.cluster.v3.Cluster.DiscoveryType proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L49>`_

Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
for an explanation on each type.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC:

STATIC
  *(DEFAULT)* ⁣Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS:

STRICT_DNS
  ⁣Refer to the :ref:`strict DNS discovery
  type<arch_overview_service_discovery_types_strict_dns>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS:

LOGICAL_DNS
  ⁣Refer to the :ref:`logical DNS discovery
  type<arch_overview_service_discovery_types_logical_dns>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.EDS:

EDS
  ⁣Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST:

ORIGINAL_DST
  ⁣Refer to the :ref:`original destination discovery
  type<arch_overview_service_discovery_types_original_destination>`
  for an explanation.
  
  

.. _envoy_v3_api_enum_config.cluster.v3.Cluster.LbPolicy:

Enum config.cluster.v3.Cluster.LbPolicy
---------------------------------------

`[config.cluster.v3.Cluster.LbPolicy proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L76>`_

Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
overview section for information on each type.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.ROUND_ROBIN:

ROUND_ROBIN
  *(DEFAULT)* ⁣Refer to the :ref:`round robin load balancing
  policy<arch_overview_load_balancing_types_round_robin>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST:

LEAST_REQUEST
  ⁣Refer to the :ref:`least request load balancing
  policy<arch_overview_load_balancing_types_least_request>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH:

RING_HASH
  ⁣Refer to the :ref:`ring hash load balancing
  policy<arch_overview_load_balancing_types_ring_hash>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RANDOM:

RANDOM
  ⁣Refer to the :ref:`random load balancing
  policy<arch_overview_load_balancing_types_random>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV:

MAGLEV
  ⁣Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
  for an explanation.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.CLUSTER_PROVIDED:

CLUSTER_PROVIDED
  ⁣This load balancer type must be specified if the configured cluster provides a cluster
  specific load balancer. Consult the configured cluster's documentation for whether to set
  this option or not.
  
  


.. _envoy_v3_api_enum_config.cluster.v3.Cluster.DnsLookupFamily:

Enum config.cluster.v3.Cluster.DnsLookupFamily
----------------------------------------------

`[config.cluster.v3.Cluster.DnsLookupFamily proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L128>`_

When V4_ONLY is selected, the DNS resolver will only perform a lookup for
addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
only perform a lookup for addresses in the IPv6 family. If AUTO is
specified, the DNS resolver will first perform a lookup for addresses in
the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
For cluster types other than
:ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
:ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
this setting is
ignored.

.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO:

AUTO
  *(DEFAULT)* ⁣
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.V4_ONLY:

V4_ONLY
  ⁣
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.V6_ONLY:

V6_ONLY
  ⁣
  

.. _envoy_v3_api_enum_config.cluster.v3.Cluster.ClusterProtocolSelection:

Enum config.cluster.v3.Cluster.ClusterProtocolSelection
-------------------------------------------------------

`[config.cluster.v3.Cluster.ClusterProtocolSelection proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L134>`_


.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL:

USE_CONFIGURED_PROTOCOL
  *(DEFAULT)* ⁣Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
  If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
  present, HTTP2 will be used, otherwise HTTP1.1 will be used.
  
  
.. _envoy_v3_api_enum_value_config.cluster.v3.Cluster.ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL:

USE_DOWNSTREAM_PROTOCOL
  ⁣Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.UpstreamBindConfig:

config.cluster.v3.UpstreamBindConfig
------------------------------------

`[config.cluster.v3.UpstreamBindConfig proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L1072>`_

An extensible structure containing the address Envoy should bind to when
establishing upstream connections.

.. code-block:: json

  {
    "source_address": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.UpstreamBindConfig.source_address:

source_address
  (:ref:`config.core.v3.Address <envoy_v3_api_msg_config.core.v3.Address>`) The address Envoy should bind to when establishing upstream connections.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.UpstreamConnectionOptions:

config.cluster.v3.UpstreamConnectionOptions
-------------------------------------------

`[config.cluster.v3.UpstreamConnectionOptions proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L1079>`_


.. code-block:: json

  {
    "tcp_keepalive": "{...}"
  }

.. _envoy_v3_api_field_config.cluster.v3.UpstreamConnectionOptions.tcp_keepalive:

tcp_keepalive
  (:ref:`config.core.v3.TcpKeepalive <envoy_v3_api_msg_config.core.v3.TcpKeepalive>`) If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
  
  


.. _envoy_v3_api_msg_config.cluster.v3.TrackClusterStats:

config.cluster.v3.TrackClusterStats
-----------------------------------

`[config.cluster.v3.TrackClusterStats proto] <https://github.com/envoyproxy/envoy/blob/0acf24ed2580c787227dc7c31f394ac583a598ae/api/envoy/config/cluster/v3/cluster.proto#L1087>`_


.. code-block:: json

  {
    "timeout_budgets": "...",
    "request_response_sizes": "..."
  }

.. _envoy_v3_api_field_config.cluster.v3.TrackClusterStats.timeout_budgets:

timeout_budgets
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If timeout_budgets is true, the :ref:`timeout budget histograms
  <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
  request. These show what percentage of a request's per try and global timeout was used. A value
  of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
  of 100 would indicate that the request took the entirety of the timeout given to it.
  
  
.. _envoy_v3_api_field_config.cluster.v3.TrackClusterStats.request_response_sizes:

request_response_sizes
  (`bool <https://developers.google.com/protocol-buffers/docs/proto#scalar>`_) If request_response_sizes is true, then the :ref:`histograms
  <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
  of requests and responses will be published.
  
  

